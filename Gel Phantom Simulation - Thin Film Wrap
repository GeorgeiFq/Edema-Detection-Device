function LUT = GelPhantom_1450_1650_SaranWrap
%% GelPhantom_1450_1650_SaranWrap
% Monte Carlo simulation of your gel phantom sweeping μs'(1450) and
% (optionally) μa(1450) scaling, with a thin "Saran wrap" layer
% between the PCB and the gel.
%
% Geometry (both λ = 1450 and 1650 nm):
%   - z = 0                 : PCB plane (LEDs + PD)
%   - 0 <= z <= t_wrap_cm   : thin plastic wrap (Saran wrap)
%   - z > t_wrap_cm         : GEL phantom
%
% Phantom:
%   - 80% water, 10% gelatin, 10% Intralipid (approx.)
%   - μa(λ) obtained from Hale–Querry water absorption data, scaled by 0.8
%     for water volume fraction.
%
% Wavelength-dependent scattering:
%   - Input sweep is μs'(1450) [cm^-1] in mu_sp_list.
%   - μs'(1650) = μs'(1450) * (1650 / 1450)^(-b), with b ≈ 1.1.
%
% μa(1450) sweep hook:
%   - We allow a scaling factor of the Hale–Querry-based μa(1450) via
%     mua1450_scale_list. This lets you see how sensitive the 1450 ratio
%     is to modest μa changes.
%
% Output LUT rows:
%   [ μs'(1450),  mua1450_scale,  (R_far/R_close)_1450,  (R_far/R_close)_1650 ]

    clc;
    MCmatlab.closeMCmatlabFigures();

    %% ===== User-tunable μs'(1450) sweep =====
    mu_sp_list = [5 10 15 20 25];   % [cm^-1]
    nMu        = numel(mu_sp_list);

    %% ===== μa(1450) scale sweep hook =====
    mua1450_scale_list = [1.0];     % e.g. [0.8 1.0 1.2]
    nScale             = numel(mua1450_scale_list);

    %% ===== Common geometry sizes =====
    nx = 101;      % x bins
    ny = 101;      % y bins
    nz = 150;      % z bins

    Lx = 5.0;      % [cm] x size  (phantom ~5 cm)
    Ly = 7.0;      % [cm] y size  (phantom ~7 cm)
    Lz = 3.0;      % [cm] z size  (phantom ~3 cm thick)

    % Source–detector separations (cm)
    SDS_list_cm = [0.3, 0.7];      % 3 mm and 7 mm

    % Monte Carlo settings
    simTime_min = 1.0;             % [min]

    % Debug plotting flags
    doPlotGeom = false;
    doPlotMC   = false;

    %% ===== Allocate LUT: [μs'(1450), muaScale1450, R1450_ratio, R1650_ratio] =====
    LUT = zeros(nMu * nScale, 4);
    row = 0;

    %% ===== Main sweep loops =====
    for iScale = 1:nScale
        muaScale1450 = mua1450_scale_list(iScale);

        fprintf('\n############################################\n');
        fprintf('  μa(1450) scale = %.3f\n', muaScale1450);
        fprintf('############################################\n');

        for iMu = 1:nMu
            mu_sp_1450 = mu_sp_list(iMu);   % μs'(1450 nm) [cm^-1]

            fprintf('\n==============================\n');
            fprintf(' Sweeping μs''(1450) = %.2f cm^-1\n', mu_sp_1450);
            fprintf('==============================\n');

            %% ----- 1450 nm model (Saran-wrap + gel) ----- 
            model1450 = MCmatlab.model;

            % Geometry
            model1450.G.nx = nx;
            model1450.G.ny = ny;
            model1450.G.nz = nz;
            model1450.G.Lx = Lx;
            model1450.G.Ly = Ly;
            model1450.G.Lz = Lz;

            % Thin plastic wrap + gel below
            model1450.G.geomFunc            = @geometryDefinition_wrap_gel;
            model1450.G.mediaPropertiesFunc = @mediaPropertiesFunc_1450_wrap;
            model1450.G.mediaPropParams     = {mu_sp_1450, muaScale1450};

            if doPlotGeom
                model1450 = plot(model1450,'G');
                title(sprintf('Geometry @ 1450 nm, μs''(1450) = %.2f', mu_sp_1450));
            end

            % MC settings
            model1450.MC.simulationTimeRequested = simTime_min;
            model1450.MC.matchedInterfaces       = false;   % use n from mediaProperties
            model1450.MC.boundaryType            = 1;       % all faces escaping
            model1450.MC.wavelength              = 1450;    % [nm]

            % Light source & collector
            model1450 = configureLightSource_Saran(model1450);
            model1450 = configureLightCollector_Saran(model1450);

            % Run for SDS = 3 mm and 7 mm
            R1450 = zeros(size(SDS_list_cm));

            fprintf('--- λ = 1450 nm ---\n');
            for k = 1:numel(SDS_list_cm)
                SDS = SDS_list_cm(k);

                % PD x-position (SDS along +x from source at x=0)
                model1450.MC.lightCollector.x = SDS;

                % Run MC
                model1450 = runMonteCarlo(model1450);

                % Store normalized collected power
                R1450(k) = model1450.MC.lightCollector.image;

                fprintf('  SDS = %.1f mm: R = %.3e W/W_incident\n', ...
                        SDS*10, R1450(k));
            end

            if doPlotMC
                model1450 = plot(model1450,'MC');
            end

            Rratio1450 = R1450(2) / R1450(1);   % R_far/R_close

            %% ----- 1650 nm model (same wrap + gel geometry) ----- 
            model1650 = MCmatlab.model;

            % Geometry
            model1650.G.nx = nx;
            model1650.G.ny = ny;
            model1650.G.nz = nz;
            model1650.G.Lx = Lx;
            model1650.G.Ly = Ly;
            model1650.G.Lz = Lz;

            model1650.G.geomFunc            = @geometryDefinition_wrap_gel;
            model1650.G.mediaPropertiesFunc = @mediaPropertiesFunc_1650_wrap;
            model1650.G.mediaPropParams     = {mu_sp_1450, muaScale1450};

            if doPlotGeom
                model1650 = plot(model1650,'G');
                title(sprintf('Geometry @ 1650 nm, μs''(1450) = %.2f', mu_sp_1450));
            end

            % MC settings
            model1650.MC.simulationTimeRequested = simTime_min;
            model1650.MC.matchedInterfaces       = false;
            model1650.MC.boundaryType            = 1;
            model1650.MC.wavelength              = 1650;    % [nm]

            % Light source & collector
            model1650 = configureLightSource_Saran(model1650);
            model1650 = configureLightCollector_Saran(model1650);

            % Run for SDS = 3 mm and 7 mm
            R1650 = zeros(size(SDS_list_cm));

            fprintf('--- λ = 1650 nm ---\n');
            for k = 1:numel(SDS_list_cm)
                SDS = SDS_list_cm(k);

                % Set PD x-position
                model1650.MC.lightCollector.x = SDS;

                % Run MC
                model1650 = runMonteCarlo(model1650);

                % Store normalized collected power
                R1650(k) = model1650.MC.lightCollector.image;

                fprintf('  SDS = %.1f mm: R = %.3e W/W_incident\n', ...
                        SDS*10, R1650(k));
            end

            if doPlotMC
                model1650 = plot(model1650,'MC');
            end

            if R1650(1) > 0
                Rratio1650 = R1650(2) / R1650(1);
            else
                Rratio1650 = NaN;
            end

            %% ----- Store in LUT -----
            row = row + 1;
            LUT(row, :) = [mu_sp_1450, muaScale1450, Rratio1450, Rratio1650];

            fprintf(['=> μs''(1450) = %.2f, scale1450 = %.3f:  ', ...
                     'R1450_far/close = %.3f,  R1650_far/close = %.3f\n'], ...
                    mu_sp_1450, muaScale1450, Rratio1450, Rratio1650);
        end
    end

    %% ===== Print final LUT nicely =====
    fprintf('\n=========== Lookup Table (μs''(1450), μa-scale sweep) ===========\n');
    fprintf('   μs''(1450) [cm^-1]   μaScale1450   (R_far/R_close)_1450   (R_far/R_close)_1650\n');
    for r = 1:row
        fprintf('   %8.3f             %8.3f          %8.3f              %8.3f\n', ...
            LUT(r,1), LUT(r,2), LUT(r,3), LUT(r,4));
    end
    fprintf('=================================================================\n');
end


%% ===== LED-like light source for Saran-wrap geometry =====
function model = configureLightSource_Saran(model)
    % Rectangular LED-like emitter at the PCB plane (z ~ 0), emitting
    % through the thin plastic wrap into the gel.
    %
    %   - sourceType = 5: X/Y factorizable rectangular
    %   - 0.3 mm × 0.3 mm emitting area (top-hat in X,Y)
    %   - Angular: cosine (Lambertian-ish) with wavelength-specific half-angle.

    model.MC.lightSource.sourceType = 5;     % X/Y factorizable rectangular

    % Beam axis centered at (0,0), pointing along +z into the wrap/gel
    model.MC.lightSource.xFocus = 0;
    model.MC.lightSource.yFocus = 0;

    % Put the emitting plane at the PCB plane z = 0
    model.MC.lightSource.zFocus = 0.0;
    model.MC.lightSource.theta  = 0;
    model.MC.lightSource.phi    = 0;

    % Focal-plane emitting area: 0.3 mm × 0.3 mm → 0.03 cm
    emitX = 0.03;   % [cm]
    emitY = 0.03;   % [cm]
    model.MC.lightSource.focalPlaneIntensityDistribution.XDistr = 1;  % top-hat
    model.MC.lightSource.focalPlaneIntensityDistribution.YDistr = 1;
    model.MC.lightSource.focalPlaneIntensityDistribution.XWidth = emitX;
    model.MC.lightSource.focalPlaneIntensityDistribution.YWidth = emitY;

    % Angular distribution
    lambda = model.MC.wavelength;

    if lambda <= 1500
        % 1450 nm LED: ~120° viewing angle → half-angle ~60°
        halfAngle_deg = 60;
    else
        % 1650 nm LED: assume narrower (e.g. ~80° total → half-angle ~40°)
        halfAngle_deg = 40;
    end

    halfAngle_rad = halfAngle_deg * pi/180;

    model.MC.lightSource.angularIntensityDistribution.XDistr = 2;  % cosine
    model.MC.lightSource.angularIntensityDistribution.YDistr = 2;
    model.MC.lightSource.angularIntensityDistribution.XWidth = halfAngle_rad;
    model.MC.lightSource.angularIntensityDistribution.YWidth = halfAngle_rad;
end


%% ===== Light collector (PD) for Saran-wrap geometry =====
function model = configureLightCollector_Saran(model)
    % PD centered at (x,0) on the PCB plane, just above the wrap.
    %
    %   - Active area ≈ 0.0095 mm² → dia ≈ 110 µm → 0.011 cm
    %   - Half-sensitivity angle ≈ ±65° → NA ≈ sin(65°) ≈ 0.91

    model.MC.useLightCollector   = true;
    model.MC.lightCollector.f    = Inf;        % single-pixel collector
    model.MC.lightCollector.y    = 0.0;        % [cm], centered in y

    % PD essentially at z = 0 plane (PCB), looking into +z (through wrap/gel)
    model.MC.lightCollector.z    = -1e-4;      % [cm] numerically "just above" z=0

    % PD diameter = 110 µm → 0.011 cm
    model.MC.lightCollector.diam = 0.011;      % [cm]

    model.MC.lightCollector.theta = 0;         % axis normal to surface
    model.MC.lightCollector.phi   = 0;

    % Half-sensitivity angle ≈ 65° → NA ≈ sin(65°) ≈ 0.91
    model.MC.lightCollector.NA    = 0.91;

    model.MC.lightCollector.res   = 1;         % single-pixel collector
end


%% ===== Geometry: thin Saran-wrap + gel (both wavelengths) =====
function M = geometryDefinition_wrap_gel(X,~,Z,~)
    % Thin Saran-wrap layer between PCB and gel.
    %
    %   0 <= z <= t_wrap_cm  → medium 1 (wrap)
    %   z >  t_wrap_cm       → medium 2 (gel phantom)
    %
    % t_wrap_cm ~ 20 µm = 0.002 cm (adjust as needed)

    t_wrap_cm = 0.002;        % [cm] ~ 20 µm

    M = ones(size(X));        % default = wrap (1)
    M(Z > t_wrap_cm) = 2;     % below wrap → gel (2)
end


%% ===== Media properties: 1450 nm (wrap + gel) =====
function mediaProperties = mediaPropertiesFunc_1450_wrap(parameters)
    % Optical properties at 1450 nm with Saran-wrap layer.
    % parameters{1} = μs'(1450 nm) [cm^-1]
    % parameters{2} = μa(1450) scale factor

    mediaProperties = MCmatlab.mediumProperties;

    %% ---- Medium 1: Saran wrap (thin plastic) ----
    j = 1;
    mediaProperties(j).name = 'wrap';
    mediaProperties(j).mua  = 0.01;   % [cm^-1] small, almost transparent
    mediaProperties(j).mus  = 0.01;   % [cm^-1] ~nonscattering (tweak if needed)
    mediaProperties(j).g    = 0.9;    % g not critical if mus is tiny
    mediaProperties(j).n    = 1.45;   % refractive index of plastic-ish wrap

    %% ---- Medium 2: Gel phantom @ 1450 nm ----
    j = 2;
    g_gel = 0.9;

    if ~isempty(parameters)
        mu_sp_1450   = parameters{1};      % μs'(1450) [cm^-1]
        if numel(parameters) >= 2
            muaScale1450 = parameters{2};
        else
            muaScale1450 = 1.0;
        end
    else
        mu_sp_1450   = 15.7;
        muaScale1450 = 1.0;
    end

    % Reduced scattering to μs
    mu_s_1450 = mu_sp_1450 / (1 - g_gel);  % convert μs' -> μs

    % Hale–Querry water μa at 1450 nm, scaled by 80% water fraction
    waterFrac = 0.8;
    mu_a_water_1450 = HQ_mua_water(1450);          % pure water [cm^-1]
    mua_mix_1450    = waterFrac * mu_a_water_1450; % phantom mix (approx)

    % Apply user scale factor
    mua_mix_1450 = mua_mix_1450 * muaScale1450;

    mediaProperties(j).name = 'gel phantom @1450nm';
    mediaProperties(j).mua  = mua_mix_1450;
    mediaProperties(j).mus  = mu_s_1450;
    mediaProperties(j).g    = g_gel;
    mediaProperties(j).n    = 1.33;      % refractive index of gel/water
end


%% ===== Media properties: 1650 nm (wrap + gel) =====
function mediaProperties = mediaPropertiesFunc_1650_wrap(parameters)
    % Optical properties at 1650 nm with Saran-wrap layer.
    % parameters{1} = μs'(1450 nm) [cm^-1]
    % parameters{2} = μa(1450) scale factor (unused here but kept for API)

    mediaProperties = MCmatlab.mediumProperties;

    %% ---- Medium 1: Saran wrap (thin plastic) ----
    j = 1;
    mediaProperties(j).name = 'wrap';
    mediaProperties(j).mua  = 0.01;   % [cm^-1] small
    mediaProperties(j).mus  = 0.01;   % [cm^-1] small
    mediaProperties(j).g    = 0.9;
    mediaProperties(j).n    = 1.45;   % plastic

    %% ---- Medium 2: Gel phantom @ 1650 nm ----
    j = 2;
    g_gel = 0.9;

    if ~isempty(parameters)
        mu_sp_1450 = parameters{1};      % μs'(1450) [cm^-1]
    else
        mu_sp_1450 = 15.7;               % default
    end

    % Power-law exponent for μs'(λ)
    b = 1.1;
    lambda_ref   = 1450;   % [nm]
    lambda_1650  = 1650;   % [nm]

    % Compute μs'(1650) via power law
    mu_sp_1650 = mu_sp_1450 * (lambda_1650 / lambda_ref)^(-b);
    mu_s_1650  = mu_sp_1650 / (1 - g_gel);  % convert μs' -> μs

    % Hale–Querry water μa at 1650 nm, scaled by 80% water fraction
    waterFrac        = 0.8;
    mu_a_water_1650  = HQ_mua_water(1650);          % [cm^-1]
    mua_mix_1650     = waterFrac * mu_a_water_1650; % phantom mix (approx)

    mediaProperties(j).name = 'gel phantom @1650nm';
    mediaProperties(j).mua  = mua_mix_1650;
    mediaProperties(j).mus  = mu_s_1650;
    mediaProperties(j).g    = g_gel;
    mediaProperties(j).n    = 1.33;
end


%% ===== Hale–Querry water absorption helper (unchanged) =====
function muaw = HQ_mua_water(lambda_nm)
    persistent lambda_tab muaw_tab
    if isempty(lambda_tab)
        lambda_tab = [1440 1460 1480 1500 1520 1540 1560 1580 1600 1620 1640 1660];
        muaw_tab   = [28.800 28.400 21.230 17.590 14.050 11.830 9.670 7.950 ...
                      6.720 5.820 4.980 4.540];
    end

    muaw = interp1(lambda_tab, muaw_tab, lambda_nm, 'linear', 'extrap');
end
